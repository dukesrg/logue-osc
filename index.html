<html>
<head>
<style>
  * {
    background-color: #111;
    color: #fff;
    font-family: sans-serif;
    outline: none;
    box-shadow: none;
    cursor: default;
  }
  *:disabled {
    color: #777;
  }
  .disabled {
    color: #777;
  }
  table.list {
    border-color: #111;
    counter-reset: rowNumber;
  }
  table.list tr td:first-child::before {
    counter-increment: rowNumber;
    content: counter(rowNumber);
  }
  .list th {
    font-size: small;
  }
  .list td, .list th {
    text-align: left;
  }
  .list td:first-of-type {
    color: #777;
  }
  .list td:nth-child(2):empty:before, .list td:nth-child(3):empty:before, .list td:nth-child(4):empty:before {
    content: "---";
  }
  div.refer {
    text-align: center;
    font-size: small;
    color: #777;
  }
  .list td:nth-child(3), .list td:nth-child(4), .list td:nth-last-child(2) {
    color: #777;
  }
  .list td:last-child {
    font-size: small;
    color: #777;
  }
  .list td {
    background-color: #000;
  }
  input {
    border: 0;
  }
  input[type="text"] {
    width: 100px;
  }
  input[type="button"] {
    background: linear-gradient(to top, #222, #444);
    border-radius: 2px;
  }
  input[type="button"]:disabled{
    background: linear-gradient(to top, #111, #111);
  }
  input[type="button"]:active, label.button:active {
    background: radial-gradient(circle, #CCC, #444);
  }
  input[type="file"] {
    position: absolute;
    top: -100px;
    width: 0px;
  }
  input[type="radio"] {
     display: none;
  }
  input[type="radio"]:checked + img {
    background: radial-gradient(circle, #CCC, #444);
  }
  img {
    background: linear-gradient(to top, #222, #444);
    border-radius: 2px;
    padding: 6px;
  }
  label.button {
    background: linear-gradient(to top, #222, #444);
    border-radius: 2px;
    padding: 1px 6px;
    font-size: small;
  }
  .popup {
    position: absolute;
    z-index: 1;
    border-style: solid;
    border-color: #fff;
    border-width: 1px;
    background-color: #333;
    color: #777;
    font-size: small;
    overflow-y: scroll;
    scrollbar-width: none;
  }
  .popup::-webkit-scrollbar {
    display: none;
  }
  .popup table {
    border-collapse: collapse;
  }
  .popup td {
    background-color: #333;
    border:none;
    padding: 4px;
  }
  .popup td:first-child {
    font-weight: bolder;
    padding-left: 8px;
  }
  .popup td:last-child {
    padding-right: 8px;
  }
  .popup tr:hover td {
    background-color: #666;
  }
</style>
<script type="text/javascript" src="jszip.js"></script>
<script type="text/javascript" src="FileSaver.js"></script>
<script language="javascript">
"use strict";
var custom_count;
var custom_params;
var custom_params_data_offset;
var custom_params_value_offset;
var offset;
var data;
var count;
var maxsize;
var op6data;
var op6fields = {
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:1-7a:2-d" : "op1Out",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:2-7a:2-d" : "op2Out",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:3-7a:2-d" : "op3Out",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:4-7a:2-d" : "op4Out",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:5-7a:2-d" : "op5Out",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:6-7a:2-d" : "op6Out",

"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:1-9a:3-8" : "op1Mode",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:2-9a:3-8" : "op2Mode",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:3-9a:3-8" : "op3Mode",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:4-9a:3-8" : "op4Mode",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:5-9a:3-8" : "op5Mode",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-a:6-9a:3-8" : "op6Mode",

"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:1-12:2-d" : "op1ModOp1",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:1-1a:3-d" : "op1ModOp2",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:1-22:4-d" : "op1ModOp3",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:1-2a:5-d" : "op1ModOp4",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:1-32:6-d" : "op1ModOp5",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:1-3a:7-d" : "op1ModOp6",

"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:2-12:2-d" : "op2ModOp1",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:2-1a:3-d" : "op2ModOp2",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:2-22:4-d" : "op2ModOp3",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:2-2a:5-d" : "op2ModOp4",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:2-32:6-d" : "op2ModOp5",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:2-3a:7-d" : "op2ModOp6",

"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:3-12:2-d" : "op3ModOp1",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:3-1a:3-d" : "op3ModOp2",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:3-22:4-d" : "op3ModOp3",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:3-2a:5-d" : "op3ModOp4",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:3-32:6-d" : "op3ModOp5",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:3-3a:7-d" : "op3ModOp6",

"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:4-12:2-d" : "op4ModOp1",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:4-1a:3-d" : "op4ModOp2",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:4-22:4-d" : "op4ModOp3",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:4-2a:5-d" : "op4ModOp4",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:4-32:6-d" : "op4ModOp5",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:4-3a:7-d" : "op4ModOp6",

"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:5-12:2-d" : "op5ModOp1",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:5-1a:3-d" : "op5ModOp2",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:5-22:4-d" : "op5ModOp3",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:5-2a:5-d" : "op5ModOp4",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:5-32:6-d" : "op5ModOp5",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:5-3a:7-d" : "op5ModOp6",

"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:6-12:2-d" : "op6ModOp1",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:6-1a:3-d" : "op6ModOp2",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:6-22:4-d" : "op6ModOp3",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:6-2a:5-d" : "op6ModOp4",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:6-32:6-d" : "op6ModOp5",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-22:9-a:6-3a:7-d" : "op6ModOp6",

"12:2-52:2-12:2-1a:2-1a:3-1a:2-12:7-8" : "algorithmNumber",
"12:2-52:2-12:2-1a:2-1a:3-1a:2-4a:c-8" : "algorithmCustom"
};

function inject(osc) {
  var platform = document.querySelector('input[name=platform]:checked').id + "unit";
  var name = document.querySelector('input[type=text][name=' + osc.name + ']').value;
  fetch(osc.name + "-osc." + platform)
  .then((response) => {
    if (response.status === 200 || response.status === 0) {
        return Promise.resolve(response.blob());
    } else {
        return Promise.reject(new Error(response.statusText));
    }
  })
  .then(JSZip.loadAsync)
  .then((zip) => {
    var manifest;
    var payload;
    Promise.all([
      zip.file(osc.name + "/payload.bin").async("Uint8Array").then((text) => {
        payload = text;
        for (var k = 0; k < custom_count[osc.name]; k++) {
          if (typeof data[k] !== 'undefined') {
            var offs = offset[osc.name][k];
            for (var i = 0; i < data[k].length; i++) {
              for (var j = 0; j < data[k][i].length; j++) {
                payload[offs++] = data[k][i][j];
              }
            }
          }
        }
        if (typeof custom_params_data_offset[osc.name] !== 'undefined') {
          for (var i = 0; i < 8; i++) {
            var param = document.querySelector('#' + osc.name + '-param' + (i + 1));
            if (param != null) {
              var param_num = custom_params[osc.name].indexOf(param.innerHTML);
              if (param_num >= 0) {
                param_num += custom_params_value_offset[osc.name];
                payload[custom_params_data_offset[osc.name] + i * 2] = param_num & 0xFF;
                payload[custom_params_data_offset[osc.name] + i * 2 + 1] = param_num >> 8;
              }
            }
          }
        }
      }),
      zip.file(osc.name + "/manifest.json").async("string").then((text) => {
        manifest = JSON.parse(text);
        manifest.header.name = name.substring(0, 12);
        for (var i = 0; i < 6; i++) {
          var param = document.querySelector('#' + osc.name + '-param' + (i + 1));
          if (param != null) {
            var param_num = custom_params[osc.name].indexOf(param.innerHTML);
            if (param_num >= 0) {
              manifest.header.params[i] = manifest.header.custom_params[param_num];
            }
          }
        }
        for (var i = 0; i < custom_count[osc.name]; i++) {
          var paramidx = manifest.header.custom_data[i][4];
          if (typeof paramidx !== 'undefined') {
            var parammul = manifest.header.custom_data[i][5];
            manifest.header.params[paramidx][2] = data[i].length * (typeof parammul == 'undefined' ? 1 : parammul) - 1;
          }
        }
        manifest = JSON.stringify(manifest, null, "  ");
      })
    ]).then(values => { 
      zip = new JSZip();
      zip.file(osc.name + "/payload.bin", payload);
      zip.file(osc.name + "/manifest.json", manifest);
      zip.generateAsync({type:"blob"}).then((blob) => saveAs(blob, osc.name + "-" + name + "." + platform));
    });
  })
}

function getInfo(osc, rowindex) {
  var platform = document.querySelector('input[name=platform]:checked').id + "unit";
  fetch(osc + "-osc." + platform)
  .then((response) => {
    if (response.status === 200 || response.status === 0) {
        return Promise.resolve(response.blob());
    } else {
        return Promise.reject(new Error(response.statusText));
    }
  })
  .then(JSZip.loadAsync)
  .then((zip) => {
    zip.file(osc + "/manifest.json").async("string").then((data) => {
      var manifest = JSON.parse(data);
      custom_count[osc] = manifest.header.custom_data.length;
      custom_params[osc] = new Array();
      offset[osc] = new Array();
      count[osc] = new Array();
      maxsize[osc] = new Array();
      var table = document.querySelector('.list');
      var row = document.createElement('tr');
      row.appendChild(document.createElement('td'));
      row.appendChild(document.createElement('td')).innerHTML = osc;
      ["version", "api"].map(e => row.appendChild(document.createElement('td')).innerHTML = manifest.header[e]);
      if (typeof manifest.header.custom_params !== 'undefined') {
        for (var i = 0; i < manifest.header.custom_params.length; i++) {
          custom_params[osc].push(manifest.header.custom_params[i][0]);
        }
      }
      for (var i = 6; i < 8; i++) {
        row.appendChild(document.createElement('td')).id = osc + '-param' + (i + 1);
      }
      manifest.header.params.map((e, i) => {
        var col = row.appendChild(document.createElement('td'));
        col.id = osc + '-param' + (i + 1);
        col.innerHTML = e[0];
        col.addEventListener("click", function() { setParam(this); }, false);
        if (custom_params[osc].indexOf(e[0]) < 0) {
          col.className = 'disabled';
        }
      });
      for (var i = 6; i > manifest.header.params.length; i--) {
        row.appendChild(document.createElement('td'));
      }
      var col = row.appendChild(document.createElement('td')).appendChild(document.createElement('label'));
      col.className = 'button';
      col.innerHTML = 'Upload';
      col = col.appendChild(document.createElement('input'));
      col.type = 'file';
      col.name = osc;
      col.accept = osc == 'Anthologue' ? '.prog_bin' : osc == 'Morpheus-U' ? '.wav' : osc == 'Morpheus-A' ? '.wav' : osc == 'Morpheus' ? '.wav' : osc == 'FM48' ? '.syx,.dx7,.32' : (osc == 'FM64' || osc == 'FM68' || osc == 'FM69') ? '.syx,.dx7,.32' : (osc == 'FM65') ? '.syx,.dx7,.32,.op6program' : '.syx,.dx7,.32,.wav';
      col.multiple = (osc != 'Morpheus-U' && osc != 'Morpheus-A' && osc != 'Morpheus');
      col.addEventListener('change', function() { handleFiles(this); }, true);
      col = row.appendChild(document.createElement('td')).appendChild(document.createElement('input'));
      col.type = 'text';
      col.name = osc;
      col.disabled = true;
      col = row.appendChild(document.createElement('td')).appendChild(document.createElement('input'));
      col.type = 'button';
      col.name = osc;
      col.disabled = true;
      col.value = 'Download';
      col.addEventListener('click', function() { inject(this); }, false);
      row.appendChild(document.createElement('td')).id = osc + '-size';
      row.appendChild(document.createElement('td')).id = osc + '-description';

      table.childNodes[1].replaceChild(row, table.childNodes[1].childNodes[rowindex + 1]);

      for (var i = 0; i < custom_count[osc]; i++) {
        if (manifest.header.custom_data[i][0] === "custom_params") {
          custom_params_data_offset[osc] = manifest.header.custom_data[i][1];
          custom_params_value_offset[osc] = manifest.header.custom_data[i][4];
          custom_count[osc]--;
        } else {
          offset[osc][i] = manifest.header.custom_data[i][1];
          count[osc][i] = manifest.header.custom_data[i][3];
          if (!count[osc][i])
            count[osc][i] = 1;
          maxsize[osc][i] = manifest.header.custom_data[i][2];
          document.querySelector('#' + osc + '-size').innerHTML += maxsize[osc][i] + ' x ' + count[osc][i] + "<br>";
          maxsize[osc][i] *= count[osc][i];
          document.querySelector('#' + osc + '-description').innerHTML += manifest.header.custom_data[i][0]+"<br>";
        }
      }
    });
    zip.file(osc + "/payload.bin").async("Uint8Array").then((data) => {
      var val, param;
      for (var i = 6; i < 8; i++) {
        param = document.querySelector('#' + osc + '-param' + (i + 1));
        if (typeof custom_params_data_offset[osc] !== 'undefined' && (val = data[custom_params_data_offset[osc] + i * 2] + (data[custom_params_data_offset[osc] + i * 2 + 1] << 8))!= i) {
          param.innerHTML = custom_params[osc][val - custom_params_value_offset[osc]];
          param.addEventListener("click", function() { setParam(this); }, false);
        } else {
          param.className = 'disabled';
        }
      }
    });
  })
}

function pcm16toulaw(val) {
  var mask;
  var seg;
  var t = 0x7FFF;

  if (val > t) {
    val = 0x8000 - (val & 0x7FFF);
    mask = 0x7F;
  } else
    mask = 0xFF;

  val += 0x84;

  for (seg = 8; seg > 0; seg--) {
    if (val > t)
      break;
    t = t >> 1;
  }

  if (seg == 8)
    val = 0x7F;
  else
    val = (seg << 4) | ((val >> (seg + 3)) & 0x0F);

  return (val ^ mask);
}

function pcm16toalaw(val) {
  var mask;
  var seg;
  var t = 0x7FFF;

  if (val > t) {
    val = 0x8000 - (val & 0x7FFF) - 8;
    mask = 0x55;
  } else
    mask = 0xD5;

  for (seg = 8; seg > 0; seg--) {
    if (val > t)
      break;
    t = t >> 1;
  }

  if (seg == 8)
    val = 0x7F;
  else if (seg < 2)
    val = (seg << 4) | ((val >> 4) & 0x0F);
  else
    val = (seg << 4) | ((val >> (seg + 3)) & 0x0F);

  return (val ^ mask);
}

function op6parse(array, position, end, address) {
  var b, id, sz, data, idx = 1;
  while (position < end) {
    b = array[position++];
    if ((b & 0x07) == 0x02) {
      id = b;
      if (b >= 0x80)
        id = (id & 0x7F) | (array[position++] << 7);
      sz = array[position++];
      if (sz >= 0x80) 
        sz = (sz & 0x7F) | (array[position++] << 7);
      if (sz > 0)
        position = op6parse(array, position, position + sz, (address === "" ? "" : (address + "-")) + id.toString(16) + ":" + idx.toString(16));
    } else {
      if (b == 0x08 || b == 0x10 || b == 0x18 || b == 0x20 || b == 0x28 || b == 0x38) {
        address += "-" + b.toString(16) ;
        b = array[position++];
        data = b;
        for (var i = 1; b >= 0x80; i++) {
          b = array[position++];
          data = (data & ((1 << (7 * i)) - 1)) | (b << (7 * i));
        }
        if (address in op6fields)
          op6data[op6fields[address]] = data;
      } else if (b == 0x0D || b == 0x1D || b == 0x25) {
        address += "-" + b.toString(16) ;
        var buffer = new ArrayBuffer(4);
        var bytes = new Uint8Array(buffer);
        for (var i = 0; i < 4; i++)
          bytes[i] = array[position + 3 - i];
        position += 4;
        data = new DataView(buffer).getFloat32(0, false);
        if (address in op6fields)
          op6data[op6fields[address]] = data;
      } else {
        if (b > 0x20) {
          position = end;
        } else {
          while (position < end) {
            b = array[position++];
          }
        }
      }
    }
    idx++;
  }
  return position;
}

function handleFiles(f) {
  var files = f.files;
  var osc = f.name;
  var rect = document.querySelector('#' + osc + '-size').getBoundingClientRect();
  var status = document.createElement('div');
  status.className = 'popup';
  status.style.left = rect.left;
  status.style.top = rect.top;
  document.body.appendChild(status);
  var name = document.querySelector('input[type=text][name=' + osc + ']');
  name.value = "";
  data = new Array();
  data[0] = new Array();
  var datalength = 0;
  status.innerHTML = "";
  for (var i = 0; i < files.length; i++) {
    var reader = new FileReader();
    reader.onload = (event) => {
      status.innerHTML += event.target.filename + ": ";
      var array = new Uint8Array(event.target.result);
      if (osc === "FM48") {
        if (array.length > 4104 || array.length < 4096) {
           status.innerHTML += "skipped (size mismatch)";
        } else {
          if (data[0].length >= count[osc][0]) {
            status.innerHTML += "skipped (maximum voice bank limit reached)";
          } else {
            if (array.length == 4096) {
              status.innerHTML += "added (assuming raw voice bank)";
              name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
              data[0].push(array);
            } else {
              switch(array.slice(0, 6).join("")) {
                case "2406709160":
                case "2406709320":
                  status.innerHTML += "skipped (6-operators voice bank not supported)";
                  break;
                case "2406704160":
                  status.innerHTML += "ignoring SysEx size mismatch, ";
                case "2406704320":
                  status.innerHTML += "added 4-operators voice bank";
                  name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  data[0].push(array.slice(6, 4102));
                  break;
                default:
                  status.innerHTML += "skipped unsupported SysEx";
              }
            }
          }
        }
      } else if (osc === "FM64" || osc === "FM67" || osc === "FM68" || osc === "FM69") {
        if (array.length > 4104 || array.length < 4096) {
           status.innerHTML += "skipped (size mismatch)";
        } else {
          if (typeof data[0] !== 'undefined' && data[0].length >= count[osc][0]) {
            status.innerHTML += "skipped (maximum voice bank limit reached)";
          } else {
            if (array.length == 4096) {
              status.innerHTML += "added (assuming raw voice bank)";
              name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
              data[0].push(array);
            } else {
              switch(array.slice(0, 6).join("")) {
                case "2406709160":
                  status.innerHTML += "ignoring SysEx size mismatch, ";
                case "2406709320":
                  status.innerHTML += "added 6-operators voice bank";
                  name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  data[0].push(array.slice(6, 4102));
                  break;
                case "2406704160":
                  status.innerHTML += "ignoring SysEx size mismatch, ";
                case "2406704320":
                  status.innerHTML += "added 4-operators voice bank";
                  name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  data[0].push(array.slice(6, 4102));
                  break;
                default:
                  status.innerHTML += "skipped unsupported SysEx";
              }
            }
          }
        }
      } else if (osc === "FM65") {
        if (array.length > 4104 || array.length < 4096) {
          if (String.fromCharCode.apply(String, array.slice(0, 4)) === "Korg" && String.fromCharCode.apply(String, array.slice(14, 25)) === ".op6program" ) {
            op6data = {};
            op6parse(array, 0x31, 0x31 + array[0x2D] + (array[0x2E] << 8) + (array[0x2F] << 16) + (array[0x30] << 24), "");
            if (op6data.algorithmNumber != 0x50 || op6data.algorithmCustom != 1) {
              status.innerHTML += "skipped (user algorithm required)";
              console.log(op6data);
            } else if (op6data.op1Mode != undefined || op6data.op2Mode != undefined || op6data.op3Mode != undefined || op6data.op4Mode != undefined || op6data.op5Mode != undefined || op6data.op6Mode != undefined) {
              status.innerHTML += "skipped (FM mode required)";
              console.log(op6data);
            } else if (typeof data[0] !== 'undefined' && data[0].length >= count[osc][0]) {
              status.innerHTML += "skipped (maximum op6program file limit reached)";
            } else {
              data[0].push(Uint8Array.from([
                op6data.op6ModOp6, op6data.op6ModOp5, op6data.op6ModOp4, op6data.op6ModOp3, op6data.op6ModOp2, op6data.op6ModOp1, op6data.op6Out,
                op6data.op5ModOp6, op6data.op5ModOp5, op6data.op5ModOp4, op6data.op5ModOp3, op6data.op5ModOp2, op6data.op5ModOp1, op6data.op4Out,
                op6data.op4ModOp6, op6data.op4ModOp5, op6data.op4ModOp4, op6data.op4ModOp3, op6data.op4ModOp2, op6data.op4ModOp1, op6data.op3Out,
                op6data.op3ModOp6, op6data.op3ModOp5, op6data.op3ModOp4, op6data.op3ModOp3, op6data.op3ModOp2, op6data.op3ModOp1, op6data.op2Out,
                op6data.op2ModOp6, op6data.op2ModOp5, op6data.op2ModOp4, op6data.op2ModOp3, op6data.op2ModOp2, op6data.op2ModOp1, op6data.op2Out,
                op6data.op1ModOp6, op6data.op1ModOp5, op6data.op1ModOp4, op6data.op1ModOp3, op6data.op1ModOp2, op6data.op1ModOp1, op6data.op1Out
              ]));
              status.innerHTML += "added opsix user algorithm";
            }
          } else {
            status.innerHTML += "skipped unsupported format";
          }
        } else {
            if (typeof data[1] !== 'undefined' && data[1].length >= count[osc][1]) {
            status.innerHTML += "skipped (maximum voice bank limit reached)";
          } else {
            if (typeof data[1] == 'undefined')
              data[1] = new Array();
            if (array.length == 4096) {
              status.innerHTML += "added (assuming raw voice bank)";
              name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
              data[1].push(array);
            } else {
              switch(array.slice(0, 6).join("")) {
                case "2406709160":
                  status.innerHTML += "ignoring SysEx size mismatch, ";
                case "2406709320":
                  status.innerHTML += "added 6-operators voice bank";
                  name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  data[1].push(array.slice(6, 4102));
                  break;
                case "2406704160":
                  status.innerHTML += "ignoring SysEx size mismatch, ";
                case "2406704320":
                  status.innerHTML += "added 4-operators voice bank";
                  name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  data[1].push(array.slice(6, 4102));
                  break;
                default:
                  status.innerHTML += "skipped unsupported SysEx";
              }
            }
          }
        }
      } else if (osc === "FM66") {
        if (array.length > 4104 || array.length < 4096) {
          if (String.fromCharCode.apply(String, array.slice(0, 4)) + String.fromCharCode.apply(String, array.slice(8, 12)) === "RIFFWAVE") {
            if (typeof data[0] !== 'undefined' && data[0].length >= count[osc][0]) {
              status.innerHTML += "skipped (maximum wave file limit reached)";
            } else {
              if (array.slice(22, 24).join("") === "10") {
                switch(array.slice(20, 22).join("") + array.slice(34, 36).join("")) {
                  case "10160": //16-bit PCM
                    var size = array[0x28] + (array[0x29] << 8) + (array[0x2A] << 16) + (array[0x2B] << 24);
                    if (size < 4096) {
                      status.innerHTML += "skipped (sample count too small)";
                    } else {
                      data[0] = new Array();
                      var newarray;
                      if (osc === "FM66") {
                        status.innerHTML += "added from 16-bit PCM";
                        if (size > 4096) {
                          status.innerHTML += ", truncated to 2048 samples";
                        }
                        newarray = new Uint8Array(257 * 8 * 2);
                        var j, k;
                        for (k = 0, j = 0; k < newarray.length / 2; k++, j++) {
                          newarray[j * 2] = array[44 + k * 2];
                          newarray[j * 2 + 1] = array[44 + k * 2 + 1];
                          if (k % 256 == 255) {
                            j++;
                            newarray[j * 2] = newarray[(j - 256) * 2];
                            newarray[j * 2 + 1] = newarray[(j - 256) * 2 + 1];
                          }
                        }
                      } else if (osc === "FM67") {
                        status.innerHTML += "added from 16-bit PCM";
                        if (size > 8192) {
                          status.innerHTML += ", truncated to 4096 samples";
                        }
                        newarray = new Uint8Array(257 * 16 * 2);
                        var j, k;
                        for (k = 0, j = 0; k < newarray.length / 2; k++, j++) {
                          newarray[j * 2] = array[44 + k * 2];
                          newarray[j * 2 + 1] = array[44 + k * 2 + 1];
                          if (k % 256 == 255) {
                            j++;
                            newarray[j * 2] = newarray[(j - 256) * 2];
                            newarray[j * 2 + 1] = newarray[(j - 256) * 2 + 1];
                          }
                        }
                      } else {
                        status.innerHTML += "added transcoded from 16-bit PCM to 32-bit PCM";
                        if (size > 4096) {
                          status.innerHTML += ", truncated to 2048 samples";
                        }
                        newarray = new Uint8Array(257 * 8 * 4);
                        var j, k;
                        for (k = 0, j = 0; k < newarray.length / 4; k++, j++) {
                          newarray[j * 4] = 0;
                          newarray[j * 4 + 1] = 0;
                          newarray[j * 4 + 2] = array[44 + k * 2];
                          newarray[j * 4 + 3] = array[44 + k * 2 + 1];
                          if (k % 256 == 255) {
                            j++;
                            newarray[j * 4] = 0;
                            newarray[j * 4 + 1] = 0;
                            newarray[j * 4 + 2] = newarray[(j - 256) * 4 + 2];
                            newarray[j * 4 + 3] = newarray[(j - 256) * 4 + 3];
                          }
                        }
                      }
                      data[0].push(newarray);
                      name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                    }
                    break;
                  case "10240": //24-bit PCM
                    var size = array[0x28] + (array[0x29] << 8) + (array[0x2A] << 16) + (array[0x2B] << 24);
                    if (size < 6144) {
                      status.innerHTML += "skipped (sample count too small)";
                    } else {
                      data[0] = new Array();
                      var newarray;
                      if (osc === "FM66") {
                        status.innerHTML += "added transcoded from 24-bit PCM to 16-bit PCM";
                        if (size > 6144) {
                          status.innerHTML += ", truncated to 2048 samples";
                        }
                        newarray = new Uint8Array(257 * 8 * 2);
                        var v, j, k;
                        for (k = 0, j = 0; k < newarray.length / 2; k++, j++) {
                          v = (array[44 + k * 3] >> 7) + (array[44 + k * 3 + 1] << 1) + (array[44 + k * 3 + 2] << 9);
                          if (v & 0x10000) {
                            if (v != 0x10000)
                              v--;
                          } else {
                            if (v != 0xFFFF)
                              v++;
                          }
                          newarray[j * 2] = (v >> 1) & 0xFF;
                          newarray[j * 2 + 1] = (v >> 9) & 0xFF;
                          if (k % 256 == 255) {
                            j++;
                            newarray[j * 2] = newarray[(j - 256) * 2];
                            newarray[j * 2 + 1] = newarray[(j - 256) * 2 + 1];
                          }
                        }
                      } else if (osc === "FM67") {
                        status.innerHTML += "added transcoded from 24-bit PCM to 16-bit PCM";
                        if (size > 12288) {
                          status.innerHTML += ", truncated to 2048 samples";
                        }
                        newarray = new Uint8Array(257 * 16 * 2);
                        var v, j, k;
                        for (k = 0, j = 0; k < newarray.length / 2; k++, j++) {
                          v = (array[44 + k * 3] >> 7) + (array[44 + k * 3 + 1] << 1) + (array[44 + k * 3 + 2] << 9);
                          if (v & 0x10000) {
                            if (v != 0x10000)
                              v--;
                          } else {
                            if (v != 0xFFFF)
                              v++;
                          }
                          newarray[j * 2] = (v >> 1) & 0xFF;
                          newarray[j * 2 + 1] = (v >> 9) & 0xFF;
                          if (k % 256 == 255) {
                            j++;
                            newarray[j * 2] = newarray[(j - 256) * 2];
                            newarray[j * 2 + 1] = newarray[(j - 256) * 2 + 1];
                          }
                        }
                      } else {
                        status.innerHTML += "added from 32-bit PCM";
                        if (size > 6144) {
                          status.innerHTML += ", truncated to 2048 samples";
                        }
                        newarray = new Uint8Array(257 * 8 * 2);
                        var j, k;
                        for (k = 0, j = 0; k < newarray.length / 4; k++, j++) {
                          newarray[j * 4] = 0;
                          newarray[j * 4 + 1] = array[44 + k * 3];
                          newarray[j * 4 + 2] = array[44 + k * 3 + 1];
                          newarray[j * 4 + 3] = array[44 + k * 3 + 2];
                          if (k % 256 == 255) {
                            j++;
                            newarray[j * 4] = 0;
                            newarray[j * 4 + 1] = newarray[(j - 256) * 4 + 1];
                            newarray[j * 4 + 2] = newarray[(j - 256) * 4 + 2];
                            newarray[j * 4 + 3] = newarray[(j - 256) * 4 + 3];
                          }
                        }
                      }
                      data[0].push(newarray);
                      name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                    }
                    break;
                  case "10320": //32-bit PCM
                    var size = array[0x28] + (array[0x29] << 8) + (array[0x2A] << 16) + (array[0x2B] << 24);
                    if (size < 8192) {
                      status.innerHTML += "skipped (sample count too small)";
                    } else {
                      data[0] = new Array();
                      var newarray;
                      if (osc === "FM66") {
                        status.innerHTML += "added transcoded from 32-bit PCM to 16-bit PCM";
                        if (size > 8192) {
                          status.innerHTML += ", truncated to 2048 samples";
                        }
                        newarray = new Uint8Array(257 * 8 * 2);
                        var v, j, k;
                        for (k = 0, j = 0; k < newarray.length / 2; k++, j++) {
                          v = (array[44 + k * 4 + 1] >> 7) + (array[44 + k * 4 + 2] << 1) + (array[44 + k * 4 + 3] << 9);
                          if (v & 0x10000) {
                            if (v != 0x10000)
                              v--;
                          } else {
                            if (v != 0xFFFF)
                              v++;
                          }
                          newarray[j * 2] = (v >> 1) & 0xFF;
                          newarray[j * 2 + 1] = (v >> 9) & 0xFF;
                          if (k % 256 == 255) {
                            j++;
                            newarray[j * 2] = newarray[(j - 256) * 2];
                            newarray[j * 2 + 1] = newarray[(j - 256) * 2 + 1];
                          }
                        }
                      } else if (osc === "FM67") {
                        status.innerHTML += "added transcoded from 32-bit PCM to 16-bit PCM";
                        if (size > 16384) {
                          status.innerHTML += ", truncated to 2048 samples";
                        }
                        newarray = new Uint8Array(257 * 16 * 2);
                        var v, j, k;
                        for (k = 0, j = 0; k < newarray.length / 2; k++, j++) {
                          v = (array[44 + k * 4 + 1] >> 7) + (array[44 + k * 4 + 2] << 1) + (array[44 + k * 4 + 3] << 9);
                          if (v & 0x10000) {
                            if (v != 0x10000)
                              v--;
                          } else {
                            if (v != 0xFFFF)
                              v++;
                          }
                          newarray[j * 2] = (v >> 1) & 0xFF;
                          newarray[j * 2 + 1] = (v >> 9) & 0xFF;
                          if (k % 256 == 255) {
                            j++;
                            newarray[j * 2] = newarray[(j - 256) * 2];
                            newarray[j * 2 + 1] = newarray[(j - 256) * 2 + 1];
                          }
                        }
                      } else {
                        status.innerHTML += "added from 32-bit PCM";
                        if (size > 8192) {
                          status.innerHTML += ", truncated to 2048 samples";
                        }
                        newarray = new Uint8Array(257 * 16 * 2);
                        var j, k;
                        for (k = 0, j = 0; k < newarray.length / 4; k++, j++) {
                          newarray[j * 4] = array[44 + k * 4];
                          newarray[j * 4 + 1] = array[44 + k * 4 + 1];
                          newarray[j * 4 + 2] = array[44 + k * 4 + 2];
                          newarray[j * 4 + 3] = array[44 + k * 4 + 3];
                          if (k % 256 == 255) {
                            j++;
                            newarray[j * 4] = newarray[(j - 256) * 4];
                            newarray[j * 4 + 1] = newarray[(j - 256) * 4 + 1];
                            newarray[j * 4 + 2] = newarray[(j - 256) * 4 + 2];
                            newarray[j * 4 + 3] = newarray[(j - 256) * 4 + 3];
                          }
                        }
                      }
                      data[0].push(newarray);
                      name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                    }
                    break;
                  default:
                    status.innerHTML += "skipped (format not supported)";
                };
              } else {
                status.innerHTML += "skipped (channel count not supported)";
              }
            }
          } else {
            status.innerHTML += "skipped (size mismatch)";
          }
        } else {
          if (typeof data[1] !== 'undefined' && data[1].length >= count[osc][1]) {
            status.innerHTML += "skipped (maximum voice bank limit reached)";
          } else {
            if (typeof data[1] == 'undefined')
              data[1] = new Array();
            if (array.length == 4096) {
              status.innerHTML += "added (assuming raw voice bank)";
              name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
              data[1].push(array);
            } else {
              switch(array.slice(0, 6).join("")) {
                case "2406709160":
                  status.innerHTML += "ignoring SysEx size mismatch, ";
                case "2406709320":
                  status.innerHTML += "added 6-operators voice bank";
                  name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  data[1].push(array.slice(6, 4102));
                  break;
                case "2406704160":
                  status.innerHTML += "ignoring SysEx size mismatch, ";
                case "2406704320":
                  status.innerHTML += "added 4-operators voice bank";
                  name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  data[1].push(array.slice(6, 4102));
                  break;
                default:
                  status.innerHTML += "skipped unsupported SysEx";
              }
            }
          }
        }
      } else if (osc === "Morpheus-U") {
        if (String.fromCharCode.apply(String, array.slice(0, 4)) + String.fromCharCode.apply(String, array.slice(8, 12)) === "RIFFWAVE") {
          if (data[0].length >= count[osc][0]) {
            status.innerHTML += "skipped (maximum wave file limit reached)";
          } else {
            if (array.slice(22, 24).join("") === "10") {
              switch(array.slice(20, 22).join("") + array.slice(34, 36).join("")) {
                case "10160": //16-bit PCM
                  var size = array[0x28] + (array[0x29] << 8) + (array[0x2A] << 16) + (array[0x2B] << 24);
                  if (size < 32768) {
                    status.innerHTML += "skipped (sample count too small)";
                  } else {
                    status.innerHTML += "added transcoded from 16-bit PCM to &#xb5;-law";
                    if (size > 32768) {
                      status.innerHTML += ", truncated to 16384 samples";
                    }
                    var newarray = new Uint8Array(16384);
                    for (i = 0; i < newarray.length; i++)
                      newarray[i] = pcm16toulaw(array[44 + i * 2] + (array[45 + i * 2] << 8));
                    data[0].push(newarray);
                    name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  }
                  break;
                case "7080": //u-Law
                  var size = array[0x2E] + (array[0x2F] << 8) + (array[0x30] << 16) + (array[0x31] << 24);
                  if (size < 16384) {
                    status.innerHTML += "skipped (sample count too small)";
                  } else {
                    status.innerHTML += "added &#xb5;-law compressed file";
                    if (size > 16384) {
                      status.innerHTML += ", truncated to 16384 samples";
                    }
                    name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                    data[0].push(array.slice(58, 16442))
                  }
                  break;
                default:
                  status.innerHTML += "skipped (format not supported)";
              }
            } else {
              status.innerHTML += "skipped (channel count not supported)";
            }
          }
        } else {
          status.innerHTML += "skipped unsupported file format";
        }
      } else if (osc === "Morpheus-A") {
        if (String.fromCharCode.apply(String, array.slice(0, 4)) + String.fromCharCode.apply(String, array.slice(8, 12)) === "RIFFWAVE") {
          if (data[0].length >= count[osc][0]) {
            status.innerHTML += "skipped (maximum wave file limit reached)";
          } else {
            if (array.slice(22, 24).join("") === "10") {
              switch(array.slice(20, 22).join("") + array.slice(34, 36).join("")) {
                case "10160": //16-bit PCM
                  var size = array[0x28] + (array[0x29] << 8) + (array[0x2A] << 16) + (array[0x2B] << 24);
                  if (size < 32768) {
                    status.innerHTML += "skipped (sample count too small)";
                  } else {
                    status.innerHTML += "added transcoded from 16-bit PCM to A-law";
                    if (size > 32768) {
                      status.innerHTML += ", truncated to 16384 samples";
                    }
                    var newarray = new Uint8Array(16384);
                    for (i = 0; i < newarray.length; i++)
                      newarray[i] = pcm16toalaw(array[44 + i * 2] + (array[45 + i * 2] << 8));
                    data[0].push(newarray);
                    name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  }
                  break;
                case "6080": //A-Law
                  var size = array[0x2E] + (array[0x2F] << 8) + (array[0x30] << 16) + (array[0x31] << 24);
                  if (size < 16384) {
                    status.innerHTML += "skipped (sample count too small)";
                  } else {
                    status.innerHTML += "added A-law compressed file";
                    if (size > 16384) {
                      status.innerHTML += ", truncated to 16384 samples";
                    }
                    name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                    data[0].push(array.slice(58, 16442))
                  }
                  break;
                default:
                  status.innerHTML += "skipped (format not supported)";
              }
            } else {
              status.innerHTML += "skipped (channel count not supported)";
            }
          }
        } else {
          status.innerHTML += "skipped unsupported file format";
        }
      } else if (osc === "Morpheus") {
        if (String.fromCharCode.apply(String, array.slice(0, 4)) + String.fromCharCode.apply(String, array.slice(8, 12)) === "RIFFWAVE") {
          if (data[0].length >= count[osc][0]) {
            status.innerHTML += "skipped (maximum wave file limit reached)";
          } else {
            if (array.slice(22, 24).join("") === "10") {
              switch(array.slice(20, 22).join("") + array.slice(34, 36).join("")) {
                case "10160": //16-bit PCM
                  var size = array[0x28] + (array[0x29] << 8) + (array[0x2A] << 16) + (array[0x2B] << 24);
                  if (size < 32768) {
                    status.innerHTML += "skipped (sample count too small)";
                  } else {
                    status.innerHTML += "added transcoded from 16-bit PCM to 8-bit linear PCM";
                    if (size > 32768) {
                      status.innerHTML += ", truncated to 16384 samples";
                    }
                    var newarray = new Uint8Array(16384);
                    for (i = 0; i < newarray.length; i++)
                      newarray[i] = array[45 + i * 2];
                    data[0].push(newarray);
                    name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  }
                  break;
                case "1080": //PCM8
                  var size = array[0x28] + (array[0x29] << 8) + (array[0x2A] << 16) + (array[0x2B] << 24);
                  if (size < 16384) {
                    status.innerHTML += "skipped (sample count too small)";
                  } else {
                    status.innerHTML += "added 8-bit linear PCM file";
                    if (size > 16384) {
                      status.innerHTML += ", truncated to 16384 samples";
                    }
                    var newarray = new Uint8Array(16384);
                    for (i = 0; i < newarray.length; i++)
                      newarray[i] = (array[44 + i] + 0x80) & 0xFF;
                    data[0].push(newarray);
                    name.value += event.target.filename.substring(0, event.target.filename.lastIndexOf("."));
                  }
                  break;
                default:
                  status.innerHTML += "skipped (format not supported)";
              }
            } else {
              status.innerHTML += "skipped (channel count not supported)";
            }
          }
        } else {
          status.innerHTML += "skipped unsupported file format";
        }
      } else if (osc === "Anthologue") {
        if (array.length != 448 && array.length != 336 && array.length != 1024) {
           status.innerHTML += "skipped (size mismatch)";
        } else {
          if (String.fromCharCode.apply(String, array.slice(0, 4)) == "PROG") {
            if (datalength + array.length > maxsize[osc][0]) {
              status.innerHTML += "skipped (maximum program limit reached)";
            } else {
              var progname = document.createElement('progname');
              progname.textContent = String.fromCharCode.apply(String, array.slice(4, 16)).replace(/\0/g,'');
              progname = progname.innerHTML;
              if (String.fromCharCode.apply(String, array.slice(96, 100)) == "SEQD") {
                status.innerHTML += "added minilogue program " + progname;
                name.value += progname;
                data[0].push(array);
                datalength += array.length;
              } else if (String.fromCharCode.apply(String, array.slice(48, 52)) == "SEQD") {
                status.innerHTML += "added monologue program " + progname;
                name.value += progname;
                data[0].push(array);
                datalength += array.length;
              } else if (String.fromCharCode.apply(String, array.slice(332, 336)) == "PRED") {
                status.innerHTML += "added prologue program " + progname;
                name.value += progname;
                data[0].push(array);
                datalength += array.length;
              } else if (String.fromCharCode.apply(String, array.slice(156, 160)) == "PRED") {
                status.innerHTML += "added minilogue xd program " + progname;
                name.value += progname;
                data[0].push(array);
                datalength += array.length;
              } else {
                status.innerHTML += "skipped unsupported file format";
              }
            }
          } else {
            status.innerHTML += "skipped unsupported file format";
          }
        }
      }
      status.innerHTML += "<br/>";
      if (data[(osc === "FM65" || osc === "FM66") ? 1 : 0].length > 0) {
        document.querySelector('input[type=button][name=' + osc + ']').disabled = false;
        name.disabled = false;
      }
    }
    reader.filename = files[i].name;
    reader.readAsArrayBuffer(files[i]);
  }
}

function platformClick(platform) {
  document.cookie = "platform=" + platform.id;
  onLoad(); 
}

function onLoad() {
  var platform = document.querySelector('#' + document.cookie.substring(document.cookie.indexOf("platform=")).split(";")[0].split("=")[1])
  if (platform)
    platform.checked = true;
  custom_count = new Array();
  custom_params = new Array();
  custom_params_data_offset = new Array();
  custom_params_value_offset = new Array();
  offset = new Array();
  count = new Array();
  maxsize = new Array();
  ["FM48", "FM64", "FM65", "FM66", "FM67", "FM68", "FM69", "Morpheus", "Anthologue"].map((e, i) => getInfo(e, i));
}

function setParam(param) {
  var dropdowns = document.getElementsByClassName("popup");
  for (var i = 0; i < dropdowns.length; i++) {
      document.body.removeChild(dropdowns[i]);
  }
  var osc = param.id.split("-");
  osc.pop();
  osc = osc.join("-");
  if (custom_params[osc].indexOf(param.innerHTML) < 0) {
    return;
  }
  var rect = param.getBoundingClientRect();
  var popup = document.createElement('div');
  popup.className = 'popup';
  var table = document.createElement('table');
  for (var i = 0; i < custom_params[osc].length; i++) {
    var row = document.createElement('tr')
    var col1 = document.createElement('td');
    var col2 = document.createElement('td');
    col2.innerHTML = custom_params[osc][i];
    if (col2.innerHTML == param.innerHTML) {
      col1.innerHTML = "&check;";
    }
    col2.addEventListener("click", function() { param.innerHTML = this.innerHTML; }, false);
    row.appendChild(col1);
    row.appendChild(col2);
    table.appendChild(row);
  }
  popup.appendChild(table);
  popup.style.left = rect.left;
  popup.style.top = rect.top;
  popup.style['max-height'] = document.getElementsByClassName("list")[0].getBoundingClientRect().bottom - rect.top;
  document.body.appendChild(popup);
}

window.onclick = function(event) {
  if (!event.target.matches('[id*=param]')) {
    var dropdowns = document.getElementsByClassName("popup");
    for (var i = 0; i < dropdowns.length; i++) {
      document.body.removeChild(dropdowns[i]);
    }
  }
}

</script>
</head>
<body onload="onLoad();">
<h3></h3>
<label><input type="radio" id="prlg" name="platform" onchange="platformClick(this);"/><img src="prlg.png"/></label>
<label><input type="radio" id="mnlgxd" name="platform" onchange="platformClick(this);"/><img src="mnlgxd.png"/></label>
<label><input type="radio" id="ntkdig" name="platform" onchange="platformClick(this);"/><img src="ntkdig.png"/></label>
<div style="width: 25%; height: 30px; line-height: 30px; font-size: small; color: #FFF; background-color: #222; text-align: center;">
USER OSCILLATORS
</div>
<table class="list" rules="rows" cellpadding="6" border="2" width="100%">
<tr><th width="40px"/><th width="100px">NAME</th><th width="70px">VERSION</th><th width="70px">API</th><th width="100px">SHAPE</th><th width="100px">ALT</th><th width="100px">PARAM 1</th><th width="100px">PARAM 2</th><th width="100px">PARAM 3</th><th width="100px">PARAM 4</th><th width="100px">PARAM 5</th><th width="100px">PARAM 6</th><th width="70px">CUSTOM&nbsp;DATA</th><th width="100px">CUSTOM&nbsp;NAME</th><th width="70px">CUSTOM&nbsp;UNIT</th><th width="70px">SIZE</th><th width="*">DESCRIPTION</th></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
<tr><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>
</table>
<div class="refer">
Refer to <a href="https://github.com/dukesrg/logue-osc">https://github.com/dukesrg/logue-osc</a> for more details on user-customizable oscillators.
</div>
</body>
</html>
